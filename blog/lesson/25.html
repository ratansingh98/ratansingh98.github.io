<!DOCTYPE html>
<html>

<head>
  <title>HOG</title>
  <meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1,minimum-scale=1">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link href="https://fonts.googleapis.com/css?family=Ubuntu:400,500,700,300&amp;subset=latin-ext" rel="stylesheet" type="text/css">
  <link href="../css/bundle.css" rel="stylesheet" type="text/css">
  <link href="../css/blog-theme.css" rel="stylesheet" type="text/css">
  <link href="../css/blog-common.css" rel="stylesheet" type="text/css">
  <link href="../icons/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  <link rel="shortcut-icon" href="/assets/icons/favicon.ico">
  <link rel="icon" href="../icons/logo.png"></head>

<body>
  <div data-blog-nav><nav class="blog-solid-nav"><div class="blog-solid-nav__inner"><a href="/index.html" class="blog-solid-nav__brand">Grandmaster.dev</a><a href="/about.html" class="blog-solid-nav__link">About</a><a href="/blog/index.html" class="blog-solid-nav__link is-active">Blog</a><a href="/contact.html" class="blog-solid-nav__link">Contact</a></div></nav></div>
  <div data-blog-banner></div>
  <section class="section-about">
    <div class="container">
      <h2>Histogram of Oriented Gradients</h2>
      <p>The Histogram of Oriented Gradient (HOG) feature descriptor is popular for object detection.</p>
      <p> In the following example, we compute the HOG descriptor and display a visualisation. </p>
      <h3>Algorithm overview</h3>
      <p>Compute a Histogram of Oriented Gradients (HOG) by</p>
      <ol>
        <li>(Optional) Global image normalisation</li>
        <li>Computing the gradient image in x and y</li>
        <li>Computing gradient histograms</li>
        <li>Normalising across blocks</li>
        <li>Flattening into a feature vector</li>
      </ol>

      <p>The first stage applies an optional global image normalisation equalisation that is designed to reduce the influence of illumination effects.
        In practice we use gamma (power law) compression, either computing the square root or the log of each color channel.
        Image texture strength is typically proportional to the local surface illumination so this compression helps to reduce the effects of local shadowing and illumination variations.
        <p>
          <p>The second stage computes first order image gradients.
            These capture contour, silhouette and some texture information, while providing further resistance to illumination variations.
            The locally dominant color channel is used, which provides color invariance to a large extent.
            Variant methods may also include second order image derivatives,
             which act as primitive bar detectors - a useful feature for capturing, e.g. bar like structures in bicycles and limbs in humans.</p>

             <p>The third stage aims to produce an encoding that is sensitive to local image content while remaining resistant to small changes in pose or appearance.
               The adopted method pools gradient orientation information locally in the same way as the SIFT [2] feature.
               The image window is divided into small spatial regions, called “cells”.
               For each cell we accumulate a local 1-D histogram of gradient or edge orientations over all the pixels in the cell.
               This combined cell-level 1-D histogram forms the basic “orientation histogram” representation.
               Each orientation histogram divides the gradient angle range into a fixed number of predetermined bins.
               The gradient magnitudes of the pixels in the cell are used to vote into the orientation histogram.</p>

               <p>The fourth stage computes normalisation, which takes local groups of cells and contrast normalises their overall responses before passing to next stage.
                 Normalisation introduces better invariance to illumination, shadowing, and edge contrast.
                 It is performed by accumulating a measure of local histogram “energy” over local groups of cells that we call “blocks”.
                 The result is used to normalise each cell in the block.
                 Typically each individual cell is shared between several blocks, but its normalisations are block dependent and thus different.
                 The cell thus appears several times in the final output vector with different normalisations.
                 This may seem redundant but it improves the performance. We refer to the normalised block descriptors as Histogram of Oriented Gradient (HOG) descriptors.</p>

                 <p>The final step collects the HOG descriptors from all blocks of a dense overlapping grid of blocks covering the detection window into a combined feature vector for use in the window classifier.</p>

<p class="line">
# Import necessary libraries<br>
<code>import numpy as np</code><br>
<code>import cv2</code><br>
<code>import matplotlib.pyplot as plt</code><br><br>

# Load image then grayscale<br>
<code>image = cv2.imread('MyPic.jpg')</code><br>
<code>gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</code><br><br>


# h, x, w in pixels<br>
<code>cell_size = (8,8)</code><br>

# h, x, w in cells<br>
<code>block_size = (2,2)</code><br>

# Number of orientation bins<br>
<code>nbins = 9</code><br><br>

# Using OpenCV's HOG Descriptor<br>
# WinSize is the size of the image cropped to multiple of the cell size<br>
<code>hog = cv2.HOGDescriptor(_winSize = (gray.shape[1] // cell_size[1] * cell_size[1],
                                   gray.shape[0] // cell_size[0] * cell_size[0]),
                                   _blockSize = (block_size[1] * cell_size[1],
                                                block_size[0] * cell_size[0]),
                                   _blockStride = (cell_size[1], cell_size[0]),
                                   _cellSize = (cell_size[1], cell_size[0]),
                                   _nbins = nbins)</code><br><br>

# Create numpy array shape which we use to create hog_feats<br>
<code>n_cells = (gray.shape[0]// cell_size[0], gray.shape[1]// cell_size[1])</code><br>

# We index blocks by rows first<br>
# hog_feats now contains the gradient amplitude for each direction,<br>
# for each celll of its group for each group. Indexing is by rows then columns.<br>
<code>hog_feats = hog.compute(gray).reshape( n_cells[1] - block_size[1] +1,
                                     n_cells[0] - block_size[0] +1,
                                     block_size[0], block_size[1],
                                     nbins).transpose((1,0,2,3,4))</code><br>

# Create our gradients array with nbins dimensions to store gradient orientations<br>
<code>gradients = np.zeros((n_cells[0], n_cells[1], nbins))</code><br>

# Create array of dimensions<br>
<code>cell_count = np.full(( n_cells[0],n_cells[1],1), 0, dtype=int)</code><br>

# Block Normalization<br>
<code>for off_y in range(block_size[0]):</code><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>for off_x in range(block_size[1]):</code><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>gradients[off_y:n_cells[0] - block_size[0] + off_y + 1, off_x:n_cells[1] - block_size[1] + off_x + 1] += hog_feats[:,:,off_y,off_x,:]</code><br>

        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>cell_count[off_y:n_cells[0] - block_size[0] + off_y +1,
                  off_x: n_cells[1] -block_size[1] + off_x + 1] += 1</code><br><br>

# Average gradients<br>
<code>gradients /= cell_count</code><br><br>

# Plot HOGs using Matplotlib<br>
# angle is 360/nbins * directions<br>
<code>color_bins = 5</code><br>
<code>plt.pcolor(gradients[:,:, color_bins])</code><br>
<code>plt.gca().invert_yaxis()</code><br>
<code>plt.gca().set_aspect('equal', adjustable='box')</code><br>
<code>plt.colorbar()</code><br>
<code>plt.title("HOG of MyPic")</code><br>
<code>plt.savefig("HOG of MyPic.jpg")</code><br>
<code>plt.show()</code><br>
<code>cv2.destroyAllWindows()</code><br>

 </p>
<p><strong>Note : </strong>Object Detection using HOG will be coming after some more topics.</p>
<br><br>
<p><strong>The input Image is: </strong></p>
<img src="../image/MyPic.jpg" height="250px"/>
 <p><strong>Output Image will be: </strong></p>
<img src="../image/HOG of MyPic.jpg" height="250px"/>
    </div>

    <div class="pagination ">
      <a class="toggler" href="24.html">Prev</a>
      <a  class="toggler" href="26.html">Next</a>
    </div>
  </section>
  <div data-blog-footer></div>
  <div class="google-rainbow">
    <div class="rainbow-item"></div>
    <div class="rainbow-item"></div>
    <div class="rainbow-item"></div>
    <div class="rainbow-item"></div>
  </div>
  <script src="../js/blog-layout.js"></script>
  <script src="../js/bundle.js"></script>
</body>

</html>
