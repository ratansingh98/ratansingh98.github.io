<!DOCTYPE html>
<html>

<head>
  <title>Watershed Algorithm</title>
  <meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1,minimum-scale=1">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link href="https://fonts.googleapis.com/css?family=Ubuntu:400,500,700,300&amp;subset=latin-ext" rel="stylesheet" type="text/css">
  <link href="../css/bundle.css" rel="stylesheet" type="text/css">
  <link href="../css/blog-theme.css" rel="stylesheet" type="text/css">
  <link href="../css/blog-common.css" rel="stylesheet" type="text/css">
  <link href="../icons/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  <link rel="shortcut-icon" href="/assets/icons/favicon.ico">
  <link rel="icon" href="../icons/logo.png"></head>

<body>
  <div data-blog-nav><nav class="blog-solid-nav"><div class="blog-solid-nav__inner"><a href="/index.html" class="blog-solid-nav__brand">Grandmaster.dev</a><a href="/about.html" class="blog-solid-nav__link">About</a><a href="/blog/index.html" class="blog-solid-nav__link is-active">Blog</a><a href="/contact.html" class="blog-solid-nav__link">Contact</a></div></nav></div>
  <div data-blog-banner></div>
  <section class="section-about">
    <div class="container">
      <h2>Watershed Algorithm</h2>
      <p>The algorithm is called
Watershed, because its conceptualization involves water. Imagine areas with low density
(little to no change) in an image as valleys, and areas with high density (lots of change) as
peaks. Start filling the valleys with water to the point where water from two different
valleys is about to merge. To prevent the merging of water from different valleys, you
build a barrier to keep them separated. The resulting barrier is the image segmentation.</p>
  <p>This is our input image</p>
  <img src="../image/basil.png" height="250px"/>

<p class="line">
    # Import Necessary Libraries<br>
  <code>import numpy as np<br></code>
<code>import cv2<br><br></code>
# Read image and convert it into grayscale<br>
<code>img = cv2.imread('basil.png')<br></code>
<code>gray = cv2.cvtColor( img, cv2.COLOR_BGR2GRAY)<br></code><br>

# Convert image into only black and white depending upon threshold<br>
<code>ret, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)<br></code>
# Create a kernel of 3x3 contains ones<br>
<code>kernel = np.ones((3,3),np.uint8)<br></code>
# Remove noise from the image by applying the morphologyEx transformation<br>
<code>opening = cv2.morphologyEx( thresh, cv2.MORPH_OPEN, kernel, iterations = 2)<br></code>
# Dilating the result of the morphology transformation, we can obtain areas of the image
that are most certainly background<br>
<code>sure_bg = cv2.dilate(opening, kernel, iterations=3)<br></code>
 # Obtain sure foreground areas by applying distanceTransform<br>
<code>dist_transform = cv2.distanceTransform( opening, cv2.DIST_L2,5)<br></code>
# Apply threshold to determine with a highly mathematical probability whether the areas are foreground.<br>
<code>ret, sure_fg = cv2.threshold( dist_transform, 0.7*dist_transform.max(), 255,0)<br></code><br>
# Subtract the sure foreground from the background<br>
<code>sure_fg = np.uint8(sure_fg)<br></code>
<code>unknown = cv2.subtract(sure_bg, sure_fg)<br></code><br>
#  We can build our famous “barriers” to stop the water from merging<br>
<code>ret, markers = cv2.connectedComponents( sure_fg)<br></code><br>
# We add 1 to the background areas because we only want unknowns to stay at 0<br>
<code>markers = markers+1<br></code>
<code>markers[unknown==255] = 0<br></code><br>
# Draw the markets on the image<br>
<code>markers = cv2.watershed(img, markers)<br></code>
<code>img[markers == -1] = [255,0,0]<br></code>
# Store image as watershed.jpg<br>
<code>cv2.imwrite("watershed.jpg", img)<br></code>
</p>



<p><strong>Output Image will be: </strong></p>
<img src="../image/watershed.jpg" height="250px"/>
<br><br>

    </div>

    <div class="pagination ">
      <a class="toggler" href="20.html">Prev</a>
      <a  class="toggler" href="22.html">Next</a>
    </div>
  </section>
  <div data-blog-footer></div>
  <div class="google-rainbow">
    <div class="rainbow-item"></div>
    <div class="rainbow-item"></div>
    <div class="rainbow-item"></div>
    <div class="rainbow-item"></div>
  </div>
  <script src="../js/blog-layout.js"></script>
  <script src="../js/bundle.js"></script>
</body>

</html>
